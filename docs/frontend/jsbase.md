# JavaScript基础

## 字面量

字面量其实就是一个值，它所代表的含义就是它字面的意思， 比如：1 2 3 4 100 "hello" true null .....，在js中所有的字面量都可以直接使用，但是直接使用字面量并不方便。

## 变量

变量可以用“存储”字面量，并且变量中存储的字面量可以随意的修改，通过变量可以对字面量进行描述，并且变量比较方便修改，变量是给字面量起一个别名。

变量中并不存储任何值，而是存储值的内存地址！

## 常量

在JS中，使用const声明常量，常量只能赋值一次，重复赋值会报错。在JS中除了常规的常量外，有一些对象类型的数据我们也可以声明为常量。

## 标识符

在JS中，所有可以由我们自主命名的内容，都可以认为是一个标识符，比如变量名、函数名、类名。使用标识符需要遵循如下的命名规范：

1. 标识符只能含有字母、数字、下划线、$，且不能以数字开头
2. 标识符不能是JS中的关键字和保留字，也不建议使用内置的函数或类名作为变量名
3. 命名规范：
    - 通常会使用驼峰命名法
    - 类名会使用大驼峰命名法
    - 常量的字母会全部大写

```js
maxlength --> maxLength
maxlength --> MaxLength
MAX_LENGTH
```

## 数据类型

### 字符串（String）

String：在JS中使用单引号或双引号来表示字符串，使用反单引号 ` 来表示模板字符串。

### 数值（Number）

Number：在JS中所有的整数和浮点数都是Number类型；

- JS中的数值并不是无限大的，当数值超过一定范围后会显示近似值；
- Infinity 是一个特殊的数值表示无穷；
- NaN 也是一个特殊的数值，表示非法的数值

大整数（BigInt）：
- 大整数用来表示一些比较大的整数，大整数使用n结尾，它可以表示的数字范围是无限大。

其他进制的数字： 
- 二进制 0b；八进制 0o ；十六进制 0x

### 布尔值（Boolean）

- 布尔值主要用来进行逻辑判断
- 布尔值只有两个true 和 false
- 使用typeof检查一个布尔值时会返回 "boolean"

### 空值 （Null）

- 空值用来表示空对象
- 空值只有一个 null
- 使用typeof检查一个空值时会返回"object"
- 使用typeof无法检查空值

### 未定义（Undefined）

- 当声明一个变量而没有赋值时，它的值就是Undefined
- Undefined类型的值只有一个就是 undefined
- 使用typeof检查一个Undefined类型的值时，会返回 "undefined"

### 符号（Symbol）

- 用来创建一个唯一的标识    
- 使用typeof检查符号时会返回 "symbol"

JS中原始值一共有七种：

1. Number
2. BigInt
3. String
4. Boolean
5. Null
6. Undefined
7. Symbol

七种原始值是构成各种数据的基石，原始值在JS中是不可变类型，一旦创建就不能修改。

## 类型转换

类型转换指将一种数据类型转换为其他类型，通常是字符串、数值和布尔值之间的互转。

### 转为字符串

调用toString()方法将其他类型转换为字符串

```js
(1).toString(); // 数字加圆括号包裹，防止后面的点被单做小数点
true.toString();
```
由于null和undefined中没有toString()，所以对这两个东西调用toString()时会报错

```js
null.toString(); // error
undefined.toString(); // error
```


调用String()函数将其他类型转换为字符串。

```js
String(null); // 'null'
String(1); // '1'
```

对于拥有toString()方法的值调用String()函数时，实际上就是在调用toString()方法。

对于null，则直接转换为"null"；对于undefined，直接转换为"undefined"

### 转为数值

使用Number()函数来将其他类型转换为数值

字符串:
- 如果字符串是一个合法的数字，则会自动转换为对应的数字
- 如果字符串不是合法数字，则转换为NaN
- 如果字符串是空串或纯空格的字符串，则转换为0

布尔值:
- true转换为1，false转换为0

null、undefined:
- null 转换为 0
- undefined 转换为 NaN

parseInt(): 
- 将一个字符串转换为一个整数
- 解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的整数
- 也可以使用parseInt()来对一个数字进行取整

```js
console.log(parseInt('100px')); // 100
```

parseFloat():
- 将一个字符串转换为浮点数 
- 解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的小数

### 转为布尔值

使用Boolean()函数来将其他类型转换为布尔值

数字:
- 0 和 NaN 转换为false
- 其余是true

字符串:
- 空串 转换为 false
- 其余是true

null、undefined:
- null、undefined 都转换为 false

对象:
- 对象会转换为true

所有表示空性的没有的错误的值都会转换为false：0、NaN、空串、null、undefined、false

## 隐式类型转换

```
转换为字符串
    显式转换
        String()
    隐式转换
        + ""
转换为数值
    显式转换
        Number()
    隐式转换
        +
转换为布尔值
    显式转换
        Boolean()
    隐式转换
        !!
```

## 运算符

运算符可以用来对一个或多个操作数（值）进行运算

### 算术运算符

```
+ 加法运算符
- 减法运算符
* 乘法运算符
/ 除法运算符
** 幂运算
% 模运算，两个数相除取余数
```

**注意：** 算术运算时，除了字符串的加法，其他运算的操作数是非数值时，都会转换为数值然后再运算


```js
// 任意一个值和字符串做加法运算时，它会先将其他值转换为字符串，然后再做拼串的操作
'1'+1; // '11'

// 他运算的操作数是非数值时，都会转换为数值然后再运算
true + 1; // 2;
```

###  赋值运算符

赋值运算符用来将一个值赋值给一个变量，一个变量只有在`=`左边时才是变量，在`=`右边时它是值


```js
=
    - 将符号右侧的值赋值给左侧的变量
??=
    - 空赋值
    - 只有当变量的值为null或undefined时才会对变量进行赋值
+=
    - a += n 等价于 a = a + n
-=
    - a -= n 等价于 a = a - n
*=
    - a *= n 等价于 a = a * n
/=
    - a /= n 等价于 a = a / n
%=
    - a %= n 等价于 a = a % n
**=
    - a **= n 等价于 a = a ** n
```

```js
const a = { duration: 50 };

a.speed ??= 25;
console.log(a.speed);
// Expected output: 25

a.duration ??= 10;
console.log(a.duration);
// Expected output: 50
```

### 一元+-

```
+ 正号: 不会改变数值的符号
- 负号: 可以对数值进行符号位取反
```

当我们对非数值类型进行正负运算时，会先将其转换为数值然后再运算

```js
let b = '123'
b = +b // b = Number(b)
```

### 自增和自减

```
++ 自增运算符:
- ++ 使用后会使得原来的变量立刻增加1
- 自增分为前自增(++a)和后自增(a++)
- 无论是++a还是a++都会使原变量立刻增加1
- 不同的是++a和a++所返回的值不同，a++ 是自增前的值（旧值），++a 是自增后的值（新值）
```

```
-- 自减运算符
- 使用后会使得原来的变量立刻减小1
- 自减分为前自减(--a)和后自减(a--)
- 无论是--a还是a--都会使原变量立刻减少1
- 不同的是--a和a--的返回值不同，--a 是新值，a-- 是旧值
```

### 逻辑运算符

```js
! 逻辑非
- ! 可以用来对一个值进行非运算
- 它可以对一个布尔值进行取反操作
    true --> false
    false --> true
- 如果对一个非布尔值进行取反，它会先将其转换为布尔值然后再取反，可以利用这个特点将其他类型转换为布尔值

```

```js
&& 逻辑与
- 可以对两个值进行与运算
- 当&&左右都为true时，则返回true，否则返回false
- 与运算是短路的与，如果第一个值为false，则不看第二个值
- 与运算是找false的，如果找到false则直接返回，没有false才会返回true
- 对于非布尔值进行与运算，它会转换为布尔值然后运算
    但是最终会返回原值
    - 如果第一个值为false，则直接返回第一个值
        如果第一个值为true，则返回第二个值
```

```js
 || 逻辑或
- 可以对两个值进行或运算
- 当||左右有true时，则返回true，否则返回false
- 或运算也是短路的或，如果第一个值为true，则不看第二个值
- 或运算是找true，如果找到true则直接返回，没有true才会返回false
- 对于非布尔值或运算，它会转换为布尔值然后运算
    但是最终会返回原值
    - 如果第一个值为true，则返回第一个
        如果第一个值为false，则返回第二个
```

### 关系运算符

关系运算符用来检查两个值之间的关系是否成立，成立返回true，不成立返回false


```js
>
    - 用来检查左值是否大于右值
>=
    - 用来检查左值是否大于或等于右值
<
    - 用来检查左值是否小于右值
<=
    - 用来检查左值是否小于或等于右值
```

- 当对非数值进行关系运算时，它会先将前转换为数值然后再比较
- 当关系运算符的两端是两个字符串，它不会将字符串转换为数值，而是逐位的比较字符的Unicode编码，利用这个特点可以对字符串按照字母排序  
- 注意比较两个字符串格式的数字时一定要进行类型转换

```js
let a = 100;
// 注意这是两个运算：先运算的1<a，结果是false，也就是0；然后 0 < 100，返回true
console.log(1 < a < 10); // true

console.log(a > 1 && a< 10); // false
```

### 相等运算符

```js
 ==
    - 相等运算符，用来比较两个值是否相等
    - 使用相等运算符比较两个不同类型的值时，
        它会将其转换为相同的类型（通常转换为数值）然后再比较
        类型转换后值相同也会返回true
    - null和undefined进行相等比较时会返回true（没有隐式类型转换为数值）
    - NaN不和任何值相等，包括它自身
===
    - 全等运算符，用来比较两个值是否全等
    - 它不会进行自动的类型转换，如果两个值的类型不同直接返回false
    - null和undefined进行全等比较时会返回false

!=
    - 不等，用来检查两个值是否不相等
    - 会自动的进行类型转换
!==
    - 不全等，比较两个值是否不全等
    - 不和自动的类型转换
```

### 条件运算符

条件表达式 ? 表达式1 : 表达式2

条件运算符在执行时，会先对条件表达式进行求值判断，如果结果为true，则执行表达式1，如果结果为false，则执行表达式2

```js
false ? alert(1) : alert(2)
```

### 运算符优先级

和数学一样，JS中的运算符也有优先级，比如先乘除和加减。

[查看运算符优先级](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

在表格中位置越靠上的优先级越高，优先级越高越先执行，优先级一样自左向右执行

## 流程控制

流程控制语句可以用来改变程序执行的顺序

使用 `{}` 来创建代码块，代码块可以用来对代码进行分组，同一个代码中的代码，就是同一组代码，一个代码块中的代码要么都执行要么都不执行

在JS中，使用let声明的变量具有块作用域，在代码块中声明的变量无法在代码块的外部访问。使用var声明的变量，不具有块作用域。

### if语句

```js
- 语法：
    if(条件表达式){
        语句...
    }

 - 执行流程
    if语句在执行会先对if后的条件表达式进行求值判断，
        如果结果为true，则执行if后的语句
        如果为false则不执行

    if语句只会控制紧随其后其后的那一行代码，如果希望可以控制多行代码，可以使用{}将语句扩起来
        最佳实践：即使if后只有1行代码，我们也应该编写代码块，这样结构会更加的清晰

    如果if中的条件表达式不是布尔值，会转换为布尔值然后再运算
```

### if-else语句

```js
- 语法：
    if(条件表达式){
        语句...
    }else{
        语句...
    }

- 执行流程：
    if-else执行时，先对条件表达式进行求值判断，
        如果结果为true 则执行if后的语句
        如果结果为false 则执行else后的语句
```

### if-else if-else语句

```js
- 语法：
    if(条件表达式){
        语句...
    }else if(条件表达式){
        语句...
    }else if(条件表达式){
        语句...
    }else if(条件表达式){
        语句...
    }else{
        语句...
    }
- 执行流程：
    if-else if-else语句，会自上向下依次对if后的条件表达式进行求值判断，
        如果条件表达式结果为true，则执行当前if后的语句，执行完毕语句结束
        如果条件表达式结果为false，则继续向下判断，直到找到true为止
        如果所有的条件表达式都是false，则执行else后的语句

    注意：
        if-else if-else语句中只会有一个代码块被执行，
            一旦有执行的代码块，下边的条件都不会在继续判断了
            所以一定要注意，条件的编写顺序

```


### switch语句

```js

switch语句
- 语法：
    switch(表达式){
        case 表达式:
            代码...
            break
        case 表达式:
            代码...
            break
        case 表达式:
            代码...
            break
        case 表达式:
            代码...
            break
        default:
            代码...
            break
    }

- 执行的流程
    switch语句在执行时，会依次将switch后的表达式和case后的表达式进行全等比较
        如果比较结果为true，则自当前case处开始执行代码
        如果比较结果为false，则继续比较其他case后的表达式，直到找到true为止
        如果所有的比较都是false，则执行default后的语句

- 注意：
    当比较结果为true时，会从当前case处开始执行代码
        也就是说case是代码执行的起始位置
    这就意味着只要是当前case后的代码，都会执行
    可以使用break来避免执行其他的case

- 总结
    switch语句和if语句的功能是重复，switch能做的事if也能做，反之亦然。
        它们最大的不同在于，switch在多个全等判断时，结构比较清晰

```

### 循环语句

通过循环语句可以使指定的代码反复执行，JS中一共有三种循环语句

- while语句
- do-while语句
- for语句

通常编写一个循环，要有三个要件: 

1. 初始化表达式（初始化变量）
2. 条件表达式（设置循环运行的条件）
3. 更新表单式（修改初始化变量）

### while循环


```js
- 语法：
    while(条件表达式){
        语句...
    }

- 执行流程：
    while语句在执行时，会先对条件表达式进行判断，
        如果结果为true，则执行循环体，执行完毕，继续判断
        如果为true，则再次执行循环体，执行完毕，继续判断，如此重复
        知道条件表达式结果为false时，循环结束
```

```js
let i = 5;
while(i>0){
    console.log(i)
    i--
}
```

### do-while循环

```js

- 语法：
    do{
        语句...
    }while(条件表达式)

- 执行顺序：
    do-while语句在执行时，会先执行do后的循环体，
        执行完毕后，会对while后的条件表达式进行判断
        如果为false，则循环终止
        如果为true，则继续执行循环体，以此类推

    和while的区别：
        while语句是先判断再执行
        do-while语句是先执行再判断

        实质的区别：
            do-while语句可以确保循环至少执行一次
```

```js
let i = 5
do{
    console.log(i)
    i--
}while(i > 0)
```

### for循环

for循环和while没有本质区别，都是用来反复执行代码，不同点就是语法结构，for循环更加清晰

```js
- 不同点就是语法结构，for循环更加清晰
- 语法：
    for(①初始化表达式; ②条件表达式; ④更新表达式){
        ③语句...
    }

- 执行流程：
    ① 执行初始化表达式，初始化变量
    ② 执行条件表达式，判断循环是否执行（true执行，false终止）
    ③ 判断结果为true，则执行循环体
    ④ 执行更新表达式，对初始化变量进行修改
    ⑤ 重复②，知道判断为false为止
- 初始化表达式，在循环的整个的生命周期中只会执行1次
- for循环中的三个表达式都可以省略
- 使用let在for循环的()中声明的变量是局部变量，只能在for循环内部访问
    使用var在for循环的()中声明的变量可以在for循环的外部访问
- 创建死循环的方式：
    while(1){}
    for(;;){}
```

```js
 for(let i=0; i<5; i++){
    console.log(i)
}
```

### break和continue

```js
 - break
    - break用来终止switch和循环语句
    - break执行后，当前的switch或循环会立刻停止
    - break会终止离他最近的循环

- continue
    - continue用来跳过当次循环
```

```js
for (let i = 0; i < 5; i++) {
    console.log(i)

    for (let j = 0; j < 5; j++) {
        if (j === 1) continue
        console.log("内层循环--->", j)
    }
}
```

## 对象

对象是JS中的一种复合数据类型，它相当于一个容器，在对象中可以存储各种不同类型数据。

### 操作对象

```js
对象中可以存储多个各种类型的数据
    对象中存储的数据，我们称为属性

向对象中添加属性：
    对象.属性名 = 属性值

读取对象中的属性
    对象.属性名
    - 如果读取的是一个对象中没有的属性
        不会报错而是返回undefined
```

```js
// 创建对象
let obj = Object()

// 添加属性
obj.name = "孙悟空"
obj.age = 18
obj.gender = "男"

// 修改属性
obj.name = "Tom sun"

// 删除属性
delete obj.name

console.log(obj.name)
```


```js
属性名
    - 通常属性名就是一个字符串，所以属性名可以是任何值，没有什么特殊要求
        但是如果你的属性名太特殊了，不能直接使用，需要使用[]来设置
        虽然如此，但是我们还是强烈建议属性名也按照标识符的规范命名

    - 也可以使用符号（symbol）作为属性名，来添加属性
        获取这种属性时，也必须使用symbol
        使用symbol添加的属性，通常是那些不希望被外界访问的属性

    - 使用[]去操作属性时，可以使用变量

属性值
    - 对象的属性值可以是任意的数据类型，也可以是一个对象

使用typeof检查一个对象时，会返回object
```

```js
let obj = Object();

obj.name = "孙悟空"
obj.if = "哈哈" // 不建议
obj.let = "嘻嘻"// 不建议
obj["1231312@#@!#!#!"] = "呵呵"// 不建议

let mySymbol = Symbol()
let newSymbol = Symbol()
// 使用symbol作为属性名
obj[mySymbol] = "通过symbol添加的属性"
```

### in 运算符

```js
in 运算符
    - 用来检查对象中是否含有某个属性
语法 
    - 属性名 in obj
    - 如果有返回true，没有返回false
```

```js
console.log("name" in obj)
```

### 对象字面量

```js
- 可以直接使用{} 来创建对象
- 使用{}所创建的对象，可以直接向对象中添加属性
- 语法：
    {
        属性名:属性值,
        [属性名]:属性值,
    }

let obj2 = {
    name:"孙悟空", 
    age:18,
    ["gender"]:"男",
    [Symbol()]:"特殊的属性",
    hello:{
        a:1,
        b:true
    }
}
```

### 枚举属性

枚举属性，指将对象中的所有的属性全部获取

```js
for-in语句
- 语法：
    for(let propName in 对象){
        语句...
    }

- for-in的循环体会执行多次，有几个属性就会执行几次，
    每次执行时，都会将一个属性名赋值给我们所定义的变量

- 注意：并不是所有的属性都可以枚举，比如 使用符号添加的属性
```

```js
let obj = {
    name:'孙悟空',
    age:18,
    gender:"男",
    address:"花果山",
    [Symbol()]:"测试的属性" // 符号添加的属性是不能枚举
}

for(let propName in obj){
    console.log(propName, obj[propName])
}
```

### 方法（method）

当一个对象的属性指向一个函数，那么我们就称这个函数是该对象的方法，调用函数就称为调用对象的方法

## 函数

```js

函数（Function）
    - 函数也是一个对象
    - 它具有其他对象所有的功能
    - 函数中可以存储代码，且可以在需要时调用这些代码

语法：
    function 函数名(){
        语句...
    }

调用函数：
    - 调用函数就是执行函数中存储的代码
    - 语法：
        函数对象()

使用typeof检查函数对象时会返回function
```

### 定义函数

```js
1.函数声明
    function 函数名(){
        语句...
    }

2.函数表达式
    const 变量 = function(){
        语句...
    }

3.箭头函数
    () => {
        语句...
    }
```

### 参数

```js

形式参数
    - 在定义函数时，可以在函数中指定数量不等的形式参数（形参）
    - 在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值

实际参数
    - 在调用函数时，可以在函数的()传递数量不等的实参
    - 实参会赋值给其对应的形参
    - 参数：
        1.如果实参和形参数量相同，则对应的实参赋值给对应的形参
        2.如果实参多余形参，则多余的实参不会使用
        3.如果形参多余实参，则多余的形参为undefined

    - 参数的类型
        - JS中不会检查参数的类型，可以传递任何类型的值作为参数

1.函数声明
        function 函数名([参数]){
            语句...
        }

2.函数表达式
    const 变量 = function([参数]){
        语句...
    }

3.箭头函数
    ([参数]) => {
        语句...
    }
```

### 返回值

```js

- 在函数中，可以通过return关键字来指定函数的返回值
    返回值就是函数的执行结果，函数调用完毕返回值便会作为结果返回

- 任何值都可以作为返回值使用（包括对象和函数之类）
    如果return后不跟任何值，则相当于返回undefined
    如果不写return，那么函数的返回值依然是undefined

- return一执行函数立即结束

function sum(a, b) {
return a + b
}
```

### 作用域

作用域指的是一个变量的可见区域，作用域有两种：

```js
全局作用域
    - 全局作用域在网页运行时创建，在网页关闭时消耗
    - 所有直接编写到script标签中的代码都位于全局作用域中
    - 全局作用域中的变量是全局变量，可以在任意位置访问

局部作用域
    - 函数作用域
        - 函数作用域在函数调用时产生，调用结束后销毁
        - 函数每次调用都会产生一个全新的函数作用域
        - 在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问
    - 块作用域
        - 块作用域是一种局部作用域
        - 块作用域在代码块执行时创建，代码块执行完毕它就销毁
        - 在块作用域中声明的变量是局部变量，只能在块内部访问，外部无法访问
```

```js
let a = "变量a"

{
    let b = "变量b"

    {
        {
            console.log(b)
        }
    }
}

{
    console.log(b)
}
```

### 作用域链

```js
  - 当我们使用一个变量时，
    JS解释器会优先在当前作用域中寻找变量，
        如果找到了则直接使用
        如果没找到，则去上一层作用域中寻找，找到了则使用
        如果没找到，则继续去上一层寻找，以此类推
        如果一直到全局作用域都没找到，则报错 xxx is not defined
```

###  Window对象

- 在浏览器中，浏览器为我们提供了一个window对象，可以直接访问
- window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作
    除此之外window对象还负责存储JS中的内置对象和浏览器的宿主对象
- window对象的属性可以通过window对象访问，也可以直接访问
- 函数就可以认为是window对象的方法


```js
var b = 20 // window.b = 20

function fn(){
    alert('我是fn')
}
```
- 在全局中使用var声明的变量，都会作为window对象的属性保存
- 使用function声明的函数，都会作为window的方法保存
- 使用let声明的变量不会存储在window对象中，而存在一个秘密的小地方（无法访问）
- var虽然没有块作用域，但有函数作用域

```js
function fn2(){
    var d = 10 // var虽然没有块作用域，但有函数作用域
    d = 10 // 在局部作用域中，如果没有使用var或let声明变量，则变量会自动成为window对象的属性 也就是全局变量

}
```

### 声明提升

```
变量的提升
    - 使用var声明的变量，它会在所有代码执行前被声明
        所以我们可以在变量声明前就访问变量

函数的提升
    - 使用函数声明创建的函数，会在其他代码执行前被创建
        所以我们可以在函数声明前调用函数


let声明的变量实际也会提升，但是在赋值之前解释器禁止对该变量的访问
```

### 立即执行函数

在开发中应该尽量减少直接在全局作用域中编写代码！

所以我们的代码要尽量编写的局部作用域

如果使用let声明的变量，可以使用{}来创建块作用域

```js
{
    let a = 10
}
```

立即执行函数（IIFE）

- 立即是一个匿名的函数，并它只会调用一次
- 可以利用IIFE来创建一个一次性的函数作用域，避免变量冲突的问题

```js
(function(){
    let a = 10
    console.log(111)
}());

 (function(){
    let a = 20
    console.log(222)
}())
```

### this

```
- 函数在调用时，JS解析器每次都会传递进一个隐含的参数
- 这个参数就叫做 this
- this会指向一个对象
    - this所指向的对象会根据函数调用方式的不同而不同
        1.以函数形式调用时，this指向的是window
        2.以方法的形式调用时，this指向的是调用方法的对象
        ...

- 通过this可以在方法中引用调用方法的对象

- 箭头函数没有自己的this，它的this有外层作用域决定，箭头函数的this和它的调用方式无关
```

关于this的详细内容，可以查看[JavaScript高级](./jsheight.md)

## 严格模式

```js
JS运行代码的模式有两种：
- 正常模式
    - 默认情况下代码都运行在正常模式中，
        在正常模式，语法检查并不严格
        它的原则是：能不报错的地方尽量不报错
    - 这种处理方式导致代码的运行性能较差

- 严格模式
    - 在严格模式下，语法检查变得严格
        1.禁止一些语法
        2.更容易报错
        3.提升了性能

- 在开发中，应该尽量使用严格模式，
    这样可以将一些隐藏的问题消灭在萌芽阶段，
        同时也能提升代码的运行性能
```

```js
"use strict" // 全局的严格模式

let a = 10

// console.log(a)

function fn(){
    "use strict" // 函数的严格的模式
}
```

## 面向对象

面向对象编程（OOP）

1. 程序是干嘛的？
    - 程序就是对现实世界的抽象（照片就是对人的抽象）
2. 对象是干嘛的？
    - 一个事物抽象到程序中后就变成了对象
    - 在程序的世界中，一切皆对象
3. 面向对象的编程
    - 面向对象的编程指，程序中的所有操作都是通过对象来完成
    - 做任何事情之前都需要先找到它的对象，然后通过对象来完成各种操作

### 类

1. 类是对象模板，可以将对象中的属性和方法直接定义在类中，定义后，就可以直接通过类来创建对象
2. 通过同一个类创建的对象，我们称为同类对象
    - 可以使用instanceof来检查一个对象是否是由某个类创建
    - 如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

```js
语法：
    class 类名 {} // 类名要使用大驼峰命名
    const 类名 = class {}  
    
通过类创建对象:
    new 类名()
```

### 属性

类的代码块，默认就是严格模式，类的代码块是用来设置对象的属性的，不是什么代码都能写

```js
 class Person{
    name = "孙悟空" // Person的实例属性name p1.name
    age = 18       // 实例属性只能通过实例访问 p1.age

    static test = "test静态属性" // 使用static声明的属性，是静态属性（类属性） Person.test
    static hh = "静态属性"   // 静态属性只能通过类去访问 Person.hh
}

const p1 = new Person();
```

## 方法

```js
 class Person{
    name = "孙悟空"
    sayHello(){
        console.log('大家好，我是' + this.name)
    } // 添加方法（实例方法） 实例方法中this就是当前实例

    static test(){
        console.log("我是静态方法", this)
    } // 静态方法（类方法） 通过类来调用 静态方法中this指向的是当前类
}
```

### 构造函数

当我们在类中直接指定实例属性的值时，意味着我们创建的所有对象的属性都是这个值，但更多的时候我们希望属性由实例决定。

在类中可以添加一个特殊的方法constructor，该方法我们称为构造函数（构造方法），构造函数会在我们调用类创建对象时执行。

```js
class Person{
    constructor(name, age, gender){
        // 可以在构造函数中，为实例属性进行赋值
        // 在构造函数中，this表示当前所创建的对象
        this.name = name
        this.age = age
        this.gender = gender
    }
}
```

### 封装

封装主要用来保证数据的安全性

1. 私有化数据
    - 将需要保护的数据设置为私有，只能在类内部使用
    - 实例使用#开头就变成了私有属性，私有属性只能在类内部访问
2. 提供setter和getter方法来开放对数据的操作
    - 属性设置私有，通过getter setter方法操作属性带来的好处
        1. 可以控制属性的读写权限
        2. 可以在方法中对属性的值进行验证


```js
class Person {
    #name
    #age
    #gender

    constructor(name, age, gender) {
        this.#name = name
        this.#age = age
        this.#gender = gender
    }

    sayHello() {
        console.log(this.#name)
    }

    // getter方法，用来读取属性
    getName(){
        return this.#name
    }

    // setter方法，用来设置属性
    setName(name){
        this.#name = name
    }

    getAge(){
        return this.#age
    }

    setAge(age){

        if(age >= 0){
            this.#age = age
        }
    }

    get gender(){
        return this.#gender
    }

    set gender(gender){
        this.#gender = gender
    }
}

 const p1 = new Person("孙悟空", 18, "男")
 // p1.getName()
 // p1.setName('猪八戒')
 // p1.setAge(-11) // p1.age = 11  p1.age
p1.gender = "女"
console.log(p1.gender)
```

### 继承

继承体现了类的扩展性

- 可以通过extends关键来完成继承
- 当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中（简单理解）
- 继承发生时，被继承的类称为 父类（超类），继承的类称为 子类
- 通过继承可以减少重复的代码，并且可以在不修改一个类的前提对其进行扩展
- 通过继承可以在不修改一个类的情况下对其进行扩展
- OCP 开闭原则，程序应该对修改关闭，对扩展开放

```js

class Animal{
    constructor(name){
        this.name = name
    }

    sayHello(){
        console.log("动物在叫~")
    }
}

class Dog extends Animal{

    // 在子类中，可以通过创建同名方法来重写父类的方法
    sayHello(){
        console.log("汪汪汪")
    }
    
}

class Cat extends Animal{

    // 重写构造函数
    constructor(name, age){
        // 重写构造函数时，构造函数的第一行代码必须为super()
        super(name) // 调用父类的构造函数

        this.age = age

    }
    
    sayHello(){

        // 调用一下父类的sayHello
        super.sayHello() // 在方法中可以使用super来引用父类的方法

        console.log("喵喵喵")
    }
}
```


### 多态

多态体现了类的灵活性，父类和子类定义了相同的方法，调用这个方法执行的结果不同，这就是多态

```js
class Animal{
    constructor(name){
        this.name = name
    }

    sayHello(){
        console.log("动物在叫~")
    }
}

class Dog extends Animal{
    sayHello(){
        console.log("汪汪汪")
    }
    
}

class Cat extends Animal{

}
const a1 = new Cat()
const a2 = new Dog();
console.log(a1.sayHello(), a2.sayHello());
```


### instanceof

instanceof 用来检查一个对象是否是一个类的实例
 - instanceof检查的是对象的原型链上是否有该类实例，只要原型链上有该类实例，就会返回true
 - Object是所有对象的原型，所以任何对象和Object进行instanceof运算都会返回true

```js
class Animal {}

class Dog extends Animal {}

const dog = new Dog()

console.log(dog instanceof Dog) // true
console.log(dog instanceof Animal) // true
console.log(dog instanceof Object) // true
```

### hasOwn

```
属性名 in 对象
    - 使用in运算符检查属性时，无论属性在对象自身还是在原型上，都会返回true

对象.hasOwnProperty(属性名) (不推荐使用)
    - 用来检查一个对象的自身是否含有某个属性

Object.hasOwn(对象, 属性名) 
    - 用来检查一个对象的自身是否含有某个属性
```

```js
class Person {
    name = "孙悟空"
    age = 18

    sayHello() {
        console.log("Hello，我是", this.name)
    }
}

const p = new Person() 
console.log("sayHello" in p) // true
console.log(p.hasOwnProperty("sayHello")) // false
console.log(Object.hasOwn(p, "sayHello")) // false
```

